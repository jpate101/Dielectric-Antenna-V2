/*!
 * chartjs-chart-smith v0.3.0
 * https://github.com/chartjs/chartjs-chart-smith
 * (c) 2020 Chart.js Contributors
 * Released under the MIT license
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(require("chart.js")):"function"==typeof define&&define.amd?define(["chart.js"],e):e((t=t||self).Chart)}(this,(function(t){"use strict";const e=(t=t&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t).helpers,i=e.options.resolve,o=e.valueOrDefault;class n extends t.controllers.line{linkScales(){}updateElement(t,e){const i=this,n=i.getMeta(),s=t.custom||{},a=i.index,r=i.getScaleForId(n.yAxisID),l=i.getScaleForId(n.xAxisID),c=n.dataset._model,d=i._resolvePointOptions(t,e),{x:h,y:p}=i.calculatePointPosition(e);t._xScale=l,t._yScale=r,t._options=d,t._datasetIndex=a,t._index=e,t._model={x:h,y:p,skip:s.skip||isNaN(h)||isNaN(p),radius:d.radius,pointStyle:d.pointStyle,rotation:d.rotation,backgroundColor:d.backgroundColor,borderColor:d.borderColor,borderWidth:d.borderWidth,tension:o(s.tension,c?c.tension:0),steppedLine:!!c&&c.steppedLine,hitRadius:d.hitRadius}}_resolvePointOptions(t,e){const o=this.chart,n=o.data.datasets[this.index],s=t.custom||{},a=o.options.elements.point,r={};let l,c,d;const h={chart:o,dataIndex:e,dataset:n,datasetIndex:this.index},p={backgroundColor:"pointBackgroundColor",borderColor:"pointBorderColor",borderWidth:"pointBorderWidth",hitRadius:"pointHitRadius",hoverBackgroundColor:"pointHoverBackgroundColor",hoverBorderColor:"pointHoverBorderColor",hoverBorderWidth:"pointHoverBorderWidth",hoverRadius:"pointHoverRadius",pointStyle:"pointStyle",radius:"pointRadius",rotation:"pointRotation"},x=Object.keys(p);for(l=0,c=x.length;l<c;++l)d=x[l],r[d]=i([s[d],n[p[d]],n[d],a[d]],h,e);return r}calculatePointPosition(t){const e=this.chart.scale,i=this.getDataset().data[t];return e.getPointPosition(i.real,i.imag)}}const s=t.helpers;class a extends t.Scale{setDimensions(){this.height=this.maxHeight,this.width=this.maxWidth,this.xCenter=this.left+Math.round(this.width/2),this.yCenter=this.top+Math.round(this.height/2),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}buildTicks(){return this.rTicks=[0,.1,.2,.3,.4,.5,.6,.7,.8,.9,1,1.2,1.4,1.6,1.8,2,3,4,5,10,20,50],this.xTicks=[-50,-20,-10,-5,-4,-3,-2,-1,-.8,-.6,-.4,-.2,0,.2,.4,.6,.8,1,2,3,4,5,10,20,50],[]}convertTicksToLabels(){return this.rLabels=this.rTicks.map((function(t,e,i){return this.options.ticks.rCallback.apply(this,[t,e,i])}),this),this.xLabels=this.xTicks.map((function(t,e,i){return this.options.ticks.xCallback.apply(this,[t,e,i])}),this),[]}calculateTickRotation(){}fit(){const e=this;e.xCenter=(e.left+e.right)/2,e.yCenter=(e.top+e.bottom)/2;const i=s.getValueOrDefault(e.options.ticks.fontSize,t.defaults.global.defaultFontSize);if(e.options.ticks.display){const o=s.getValueOrDefault(e.options.ticks.fontStyle,t.defaults.global.defaultFontStyle),n=s.getValueOrDefault(e.options.ticks.fontFamily,t.defaults.global.defaultFontFamily),a=s.fontString(i,o,n);e.ctx.font=a;const r=e.xLabels.map(t=>e.ctx.measureText(t).width);e.minDimension=Math.min(e.right-e.left,e.bottom-e.top),s.each(e.xTicks,(t,o)=>{if(0!==t){const n=e.minDimension/2,a=e.getPointPosition(0,t),l=(a.x-e.xCenter)/n,c=(a.y-e.yCenter)/n,d=r[o]+e.options.ticks.padding,h=[{x:a.x+l*d+c*i,y:a.y+c*d-l*i},{x:a.x+l*d-c*i,y:a.y+c*d+l*i}];s.each(h,t=>{e.paddingLeft=Math.max(e.paddingLeft,e.left-t.x),e.paddingTop=Math.max(e.paddingTop,e.top-t.y),e.paddingRight=Math.max(e.paddingRight,t.x-e.right),e.paddingBottom=Math.max(e.paddingBottom,t.y-e.bottom)})}})}e.minDimension=Math.min(e.right-e.left-e.paddingLeft-e.paddingRight,e.bottom-e.top-e.paddingBottom-e.paddingTop),e.arcs=[],e.rLabelPoints=[],e.xLabelPoints=[],s.each(e.rTicks,t=>{const i=1/(1+t)*(e.minDimension/2),o=e.xCenter+t/(1+t)*(e.minDimension/2);e.arcs.push({x:o,y:e.yCenter,r:i,s:0,e:2*Math.PI,cc:!1}),e.rLabelPoints.push({x:o-i,y:e.yCenter})}),s.each(e.xTicks,t=>{if(0!==t){const i=1/Math.abs(t)*(e.minDimension/2),o=e.xCenter+e.minDimension/2,n=t>0?e.yCenter-i:e.yCenter+i,s=Math.sqrt(Math.pow(o-e.xCenter,2)+Math.pow(n-e.yCenter,2)),a=Math.atan2(e.yCenter-n,e.xCenter-o),r=(t>0?.5:-.5)*Math.acos((Math.pow(i,2)-Math.pow(e.minDimension/2,2))/Math.pow(s,2))+a,l=t>0?.5*Math.PI:-.5*Math.PI;e.arcs.push({x:o,y:n,r:i,s:l,e:r,cc:t<=0}),e.xLabelPoints.push({x:o+Math.cos(r)*i,y:n+Math.sin(r)*i})}else e.xLabelPoints.push(null)})}draw(){const e=this;if(e.options.display&&(e.options.gridLines.display?(e.ctx.strokeStyle=e.options.gridLines.color,e.ctx.lineWidth=e.options.gridLines.lineWidth,e.ctx.beginPath(),e.ctx.moveTo(e.xCenter-e.minDimension/2,e.yCenter),e.ctx.lineTo(e.xCenter+e.minDimension/2,e.yCenter),e.ctx.stroke(),s.each(e.arcs,t=>{e.ctx.beginPath(),e.ctx.arc(t.x,t.y,t.r,t.s,t.e,t.cc),e.ctx.stroke()})):(e.ctx.strokeStyle=e.options.gridLines.color,e.ctx.lineWidth=e.options.gridLines.lineWidth,e.ctx.beginPath(),e.ctx.arc(e.xCenter,e.yCenter,e.minDimension/2,0,2*Math.PI,!1),e.ctx.stroke()),e.options.ticks.display)){const i=s.getValueOrDefault(e.options.ticks.fontSize,t.defaults.global.defaultFontSize),o=s.getValueOrDefault(e.options.ticks.fontStyle,t.defaults.global.defaultFontStyle),n=s.getValueOrDefault(e.options.ticks.fontFamily,t.defaults.global.defaultFontFamily),a=s.fontString(i,o,n);e.ctx.font=a,e.ctx.fillStyle=s.getValueOrDefault(e.options.ticks.fontColor,t.defaults.global.defaultFontColor),s.each(e.rLabels,(t,i)=>{const o=e.rLabelPoints[i];e.ctx.save(),e.ctx.translate(o.x,o.y),e.ctx.rotate(-.5*Math.PI),e.ctx.textBaseline="middle",e.ctx.textAlign="center",e.ctx.fillText(t,0,0),e.ctx.restore()}),s.each(e.xLabels,(t,i)=>{const o=e.xLabelPoints[i];if(o){let i="left",n=Math.atan2(o.y-e.yCenter,o.x-e.xCenter),s=e.options.ticks.padding;o.x<e.xCenter&&(n+=Math.PI,i="right",s*=-1),e.ctx.save(),e.ctx.translate(o.x,o.y),e.ctx.rotate(n),e.ctx.textBaseline="middle",e.ctx.textAlign=i,e.ctx.fillText(t,s,0),e.ctx.restore()}})}}getPointPosition(t,e){const i=1/(1+t)*(this.minDimension/2),o=this.xCenter+t/(1+t)*(this.minDimension/2),n=this.yCenter,s=1/Math.abs(e)*(this.minDimension/2),a=this.xCenter+this.minDimension/2,r=e>0?this.yCenter-s:this.yCenter+s,l=Math.sqrt(Math.pow(a-o,2)+Math.pow(r-n,2)),c=Math.atan2(n-r,o-a),d=Math.acos((Math.pow(s,2)-Math.pow(i,2))/Math.pow(l,2)),h=e>0?.5*d+c:-.5*d+c;return{x:0===e?o-i:Math.cos(h)*s+a,y:0===e?this.yCenter:Math.sin(h)*s+r}}getLabelForIndex(t,e){const i=this.chart.data.datasets[e].data[t];return i.real+" + "+i.imag+"i"}}t.controllers.smith=n,t.defaults.smith={aspectRatio:1,scale:{type:"smith"},tooltips:{callbacks:{title:()=>null,label:(t,e)=>{const i=e.datasets[t.datasetIndex],o=i.data[t.index];return i.label+": "+o.real+" + "+o.imag+"i"}}}},t.scaleService.registerScaleType("smith",a,{position:"chartArea",display:!0,ticks:{padding:5,rCallback:t=>t.toString(),xCallback:t=>t.toString()+"i"}})}));
